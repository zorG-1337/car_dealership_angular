import { isPlatformBrowser } from '@angular/common';
import { Directive, ElementRef, Input, Output, forwardRef, Renderer2, EventEmitter, PLATFORM_ID, inject } from '@angular/core';
import { NG_VALUE_ACCESSOR, COMPOSITION_BUFFER_MODE } from '@angular/forms';
import { IMASK_FACTORY } from './imask-factory-token';
import * as i0 from "@angular/core";
export const MASKEDINPUT_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => IMaskDirective),
    multi: true,
};
export const DEFAULT_IMASK_ELEMENT = (elementRef) => elementRef.nativeElement;
export class IMaskDirective {
    constructor() {
        this.onTouched = () => { };
        this.onChange = () => { };
        this._viewInitialized = false;
        this._composing = false;
        this._writing = false;
        this._elementRef = inject(ElementRef);
        this._renderer = inject(Renderer2);
        this._factory = inject(IMASK_FACTORY);
        this._platformId = inject(PLATFORM_ID);
        this._compositionMode = inject(COMPOSITION_BUFFER_MODE, { optional: true }) ?? !this._isAndroid();
        this.imaskElement = DEFAULT_IMASK_ELEMENT;
        this.accept = new EventEmitter();
        this.complete = new EventEmitter();
    }
    get element() {
        return this.imaskElement(this._elementRef, this);
    }
    get maskValue() {
        if (!this.maskRef)
            return (this.element?.value || '');
        if (this.unmask === 'typed')
            return this.maskRef.typedValue;
        if (this.unmask)
            return this.maskRef.unmaskedValue;
        return this.maskRef.value;
    }
    set maskValue(value) {
        if (this.maskRef) {
            if (this.unmask === 'typed')
                this.maskRef.typedValue = value;
            else if (this.unmask)
                this.maskRef.unmaskedValue = value;
            else
                this.maskRef.value = value;
        }
        else {
            this._renderer.setProperty(this.element, 'value', value);
        }
    }
    ngAfterViewInit() {
        if (this.imask)
            this.initMask();
        this._viewInitialized = true;
    }
    ngOnChanges(changes) {
        if (changes['elementRef'] && !this.imaskElement)
            this.imaskElement = DEFAULT_IMASK_ELEMENT;
        if (!changes['imask'] || !this._viewInitialized)
            return;
        if (this.imask) {
            if (this.maskRef)
                this.maskRef.updateOptions(this.imask);
            else {
                this.initMask();
                this.onChange(this.maskValue);
            }
        }
        else {
            this.destroyMask();
        }
    }
    destroyMask() {
        if (this.maskRef) {
            this.maskRef.destroy();
            delete this.maskRef;
        }
    }
    ngOnDestroy() {
        this.destroyMask();
        this.accept.complete();
        this.complete.complete();
    }
    beginWrite(value) {
        this._writing = true;
        this._writingValue = value;
    }
    endWrite() {
        this._writing = false;
        return this._writingValue;
    }
    writeValue(value) {
        value = (value == null && this.unmask !== 'typed' ? '' : value);
        if (this.maskRef) {
            this.beginWrite(value);
            this.maskValue = value;
            this.endWrite();
        }
        else {
            this._renderer.setProperty(this.element, 'value', value);
            this._initialValue = value;
        }
    }
    _onAccept() {
        const value = this.maskValue;
        // if value was not changed during writing don't fire events
        // for details see https://github.com/uNmAnNeR/imaskjs/issues/136
        if (this._writing && value === this.endWrite())
            return;
        this.onChange(value);
        this.accept.emit(value);
    }
    _onComplete() {
        this.complete.emit(this.maskValue);
    }
    initMask() {
        this.maskRef = this._factory.create(this.element, this.imask)
            .on('accept', this._onAccept.bind(this))
            .on('complete', this._onComplete.bind(this));
        if (this._initialValue != null)
            this.writeValue(this._initialValue);
        delete this._initialValue;
    }
    setDisabledState(isDisabled) {
        this._renderer.setProperty(this.element, 'disabled', isDisabled);
    }
    registerOnChange(fn) { this.onChange = fn; }
    registerOnTouched(fn) { this.onTouched = fn; }
    _handleInput(value) {
        // if mask is attached all input goes throw mask
        if (this.maskRef)
            return;
        if (!this._compositionMode || (this._compositionMode && !this._composing)) {
            this.onChange(value);
        }
    }
    _compositionStart() { this._composing = true; }
    _compositionEnd(value) {
        this._composing = false;
        this._compositionMode && this._handleInput(value);
    }
    _isAndroid() {
        return isPlatformBrowser(this._platformId) && /android (\d+)/.test(navigator.userAgent.toLowerCase());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IMaskDirective, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "16.2.12", type: IMaskDirective, isStandalone: true, selector: "[imask]", inputs: { imask: "imask", unmask: "unmask", imaskElement: "imaskElement" }, outputs: { accept: "accept", complete: "complete" }, host: { listeners: { "input": "_handleInput($event.target.value)", "blur": "onTouched()", "compositionstart": "_compositionStart()", "compositionend": "_compositionEnd($event.target.value)" } }, providers: [MASKEDINPUT_VALUE_ACCESSOR], exportAs: ["imask"], usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "16.2.12", ngImport: i0, type: IMaskDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[imask]',
                    standalone: true,
                    exportAs: 'imask',
                    host: {
                        '(input)': '_handleInput($event.target.value)',
                        '(blur)': 'onTouched()',
                        '(compositionstart)': '_compositionStart()',
                        '(compositionend)': '_compositionEnd($event.target.value)'
                    },
                    providers: [MASKEDINPUT_VALUE_ACCESSOR],
                }]
        }], propDecorators: { imask: [{
                type: Input
            }], unmask: [{
                type: Input
            }], imaskElement: [{
                type: Input
            }], accept: [{
                type: Output
            }], complete: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW1hc2suZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2ltYXNrLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNwRCxPQUFPLEVBQ0wsU0FBUyxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBWSxTQUFTLEVBQ3JFLFlBQVksRUFDRyxXQUFXLEVBQUUsTUFBTSxFQUNuQyxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLEVBQUUsaUJBQWlCLEVBQXdCLHVCQUF1QixFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDbEcsT0FBTyxFQUFFLGFBQWEsRUFBRSxNQUFNLHVCQUF1QixDQUFDOztBQUt0RCxNQUFNLENBQUMsTUFBTSwwQkFBMEIsR0FBYTtJQUNsRCxPQUFPLEVBQUUsaUJBQWlCO0lBQzFCLFdBQVcsRUFBRSxVQUFVLENBQUMsR0FBRyxFQUFFLENBQUMsY0FBYyxDQUFDO0lBQzdDLEtBQUssRUFBRSxJQUFJO0NBQ1osQ0FBQztBQVNGLE1BQU0sQ0FBQyxNQUFNLHFCQUFxQixHQUFHLENBQUMsVUFBZSxFQUFFLEVBQUUsQ0FBQyxVQUFVLENBQUMsYUFBYSxDQUFDO0FBYW5GLE1BQU0sT0FBTyxjQUFjO0lBWjNCO1FBa0JFLGNBQVMsR0FBUSxHQUFHLEVBQUUsR0FBRSxDQUFDLENBQUM7UUFDMUIsYUFBUSxHQUFRLEdBQUcsRUFBRSxHQUFFLENBQUMsQ0FBQztRQUNqQixxQkFBZ0IsR0FBRyxLQUFLLENBQUM7UUFFekIsZUFBVSxHQUFHLEtBQUssQ0FBQztRQUVuQixhQUFRLEdBQUcsS0FBSyxDQUFDO1FBRWpCLGdCQUFXLEdBQUcsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDO1FBQ2pDLGNBQVMsR0FBRyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDOUIsYUFBUSxHQUFHLE1BQU0s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O1lBQ3pFLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7U0FDdEI7SUFDSCxDQUFDO0lBRUQsaUJBQWlCLEtBQVcsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDO0lBRXJELGVBQWUsQ0FBQyxLQUFVO1FBQ3hCLElBQUksQ0FBQyxVQUFVLEdBQUcsS0FBSyxDQUFDO1FBQ3hCLElBQUksQ0FBQyxnQkFBZ0IsSUFBSSxJQUFJLENBQUMsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3BELENBQUM7SUFFTyxVQUFVO1FBQ2hCLE9BQU8saUJBQWlCLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLGVBQWUsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO0lBQ3hHLENBQUM7K0dBekpVLGNBQWM7bUdBQWQsY0FBYywwWEFGZCxDQUFDLDBCQUEwQixDQUFDOzs0RkFFNUIsY0FBYztrQkFaMUIsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsU0FBUztvQkFDbkIsVUFBVSxFQUFFLElBQUk7b0JBQ2hCLFFBQVEsRUFBRSxPQUFPO29CQUNqQixJQUFJLEVBQUU7d0JBQ0osU0FBUyxFQUFFLG1DQUFtQzt3QkFDOUMsUUFBUSxFQUFFLGFBQWE7d0JBQ3ZCLG9CQUFvQixFQUFFLHFCQUFxQjt3QkFDM0Msa0JBQWtCLEVBQUUsc0NBQXNDO3FCQUMzRDtvQkFDRCxTQUFTLEVBQUUsQ0FBQywwQkFBMEIsQ0FBQztpQkFDeEM7OEJBcUJVLEtBQUs7c0JBQWIsS0FBSztnQkFDRyxNQUFNO3NCQUFkLEtBQUs7Z0JBQ0csWUFBWTtzQkFBcEIsS0FBSztnQkFDSSxNQUFNO3NCQUFmLE1BQU07Z0JBQ0csUUFBUTtzQkFBakIsTUFBTSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHR5cGUgSW5wdXRNYXNrLCB0eXBlIElucHV0TWFza0VsZW1lbnQsIHR5cGUgRmFjdG9yeUFyZywgdHlwZSBVcGRhdGVPcHRzIH0gZnJvbSAnaW1hc2snO1xuaW1wb3J0IHsgaXNQbGF0Zm9ybUJyb3dzZXIgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtcbiAgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbnB1dCwgT3V0cHV0LCBmb3J3YXJkUmVmLCBQcm92aWRlciwgUmVuZGVyZXIyLFxuICBFdmVudEVtaXR0ZXIsIE9uRGVzdHJveSwgT25DaGFuZ2VzLCBBZnRlclZpZXdJbml0LFxuICBTaW1wbGVDaGFuZ2VzLCBQTEFURk9STV9JRCwgaW5qZWN0XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTkdfVkFMVUVfQUNDRVNTT1IsIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBDT01QT1NJVElPTl9CVUZGRVJfTU9ERSB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IElNQVNLX0ZBQ1RPUlkgfSBmcm9tICcuL2ltYXNrLWZhY3RvcnktdG9rZW4nO1xuXG5leHBvcnRcbnR5cGUgRmFsc3kgPSBmYWxzZSB8IDAgfCBcIlwiIHwgbnVsbCB8IHVuZGVmaW5lZDtcblxuZXhwb3J0IGNvbnN0IE1BU0tFRElOUFVUX1ZBTFVFX0FDQ0VTU09SOiBQcm92aWRlciA9IHtcbiAgcHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsXG4gIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IElNYXNrRGlyZWN0aXZlKSxcbiAgbXVsdGk6IHRydWUsXG59O1xuXG5leHBvcnRcbnR5cGUgVmFsdWU8T3B0cyBleHRlbmRzIEZhY3RvcnlBcmcsIFVubWFzayBleHRlbmRzICgndHlwZWQnIHwgYm9vbGVhbik+ID1cbiAgVW5tYXNrIGV4dGVuZHMgJ3R5cGVkJyA/IElucHV0TWFzazxPcHRzPlsndHlwZWRWYWx1ZSddIDpcbiAgVW5tYXNrIGV4dGVuZHMgRmFsc3kgPyBJbnB1dE1hc2s8T3B0cz5bJ3ZhbHVlJ10gOlxuICBJbnB1dE1hc2s8T3B0cz5bJ3VubWFza2VkVmFsdWUnXVxuO1xuXG5leHBvcnQgY29uc3QgREVGQVVMVF9JTUFTS19FTEVNRU5UID0gKGVsZW1lbnRSZWY6IGFueSkgPT4gZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50O1xuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW2ltYXNrXScsXG4gIHN0YW5kYWxvbmU6IHRydWUsXG4gIGV4cG9ydEFzOiAnaW1hc2snLFxuICBob3N0OiB7XG4gICAgJyhpbnB1dCknOiAnX2hhbmRsZUlucHV0KCRldmVudC50YXJnZXQudmFsdWUpJyxcbiAgICAnKGJsdXIpJzogJ29uVG91Y2hlZCgpJyxcbiAgICAnKGNvbXBvc2l0aW9uc3RhcnQpJzogJ19jb21wb3NpdGlvblN0YXJ0KCknLFxuICAgICcoY29tcG9zaXRpb25lbmQpJzogJ19jb21wb3NpdGlvbkVuZCgkZXZlbnQudGFyZ2V0LnZhbHVlKSdcbiAgfSxcbiAgcHJvdmlkZXJzOiBbTUFTS0VESU5QVVRfVkFMVUVfQUNDRVNTT1JdLFxufSlcbmV4cG9ydCBjbGFzcyBJTWFza0RpcmVjdGl2ZTxcbiAgT3B0cyBleHRlbmRzIEZhY3RvcnlBcmcsXG4gIFVubWFzayBleHRlbmRzICgndHlwZWQnIHwgYm9vbGVhbikgPSBmYWxzZSxcbiAgViA9IFZhbHVlPE9wdHMsIFVubWFzaz4sXG4+IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3IsIEFmdGVyVmlld0luaXQsIE9uRGVzdHJveSwgT25DaGFuZ2VzIHtcbiAgbWFza1JlZj86IElucHV0TWFzazxPcHRzPjtcbiAgb25Ub3VjaGVkOiBhbnkgPSAoKSA9PiB7fTtcbiAgb25DaGFuZ2U6IGFueSA9ICgpID0+IHt9O1xuICBwcml2YXRlIF92aWV3SW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgcHJpdmF0ZSBfaW5pdGlhbFZhbHVlOiBhbnk7XG4gIHByaXZhdGUgX2NvbXBvc2luZyA9IGZhbHNlO1xuICBwcml2YXRlIF93cml0aW5nVmFsdWU6IGFueTtcbiAgcHJpdmF0ZSBfd3JpdGluZyA9IGZhbHNlO1xuXG4gIHByaXZhdGUgX2VsZW1lbnRSZWYgPSBpbmplY3QoRWxlbWVudFJlZik7XG4gIHByaXZhdGUgX3JlbmRlcmVyID0gaW5qZWN0KFJlbmRlcmVyMik7XG4gIHByaXZhdGUgX2ZhY3RvcnkgPSBpbmplY3QoSU1BU0tfRkFDVE9SWSk7XG4gIHByaXZhdGUgX3BsYXRmb3JtSWQgPSBpbmplY3QoUExBVEZPUk1fSUQpO1xuICBwcml2YXRlIF9jb21wb3NpdGlvbk1vZGUgPSBpbmplY3QoQ09NUE9TSVRJT05fQlVGRkVSX01PREUsIHtvcHRpb25hbDogdHJ1ZX0pID8/ICF0aGlzLl9pc0FuZHJvaWQoKTtcblxuICBASW5wdXQoKSBpbWFzaz86IE9wdHM7XG4gIEBJbnB1dCgpIHVubWFzaz86IFVubWFzaztcbiAgQElucHV0KCkgaW1hc2tFbGVtZW50OiAoZWxlbWVudFJlZjogRWxlbWVudFJlZiwgZGlyZWN0aXZlUmVmOiBhbnkpID0+IElucHV0TWFza0VsZW1lbnQgPSBERUZBVUxUX0lNQVNLX0VMRU1FTlQ7XG4gIEBPdXRwdXQoKSBhY2NlcHQgPSBuZXcgRXZlbnRFbWl0dGVyPFY+KCk7XG4gIEBPdXRwdXQoKSBjb21wbGV0ZSA9IG5ldyBFdmVudEVtaXR0ZXI8Vj4oKTtcblxuICBnZXQgZWxlbWVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1hc2tFbGVtZW50KHRoaXMuX2VsZW1lbnRSZWYsIHRoaXMpO1xuICB9XG5cbiAgZ2V0IG1hc2tWYWx1ZSAoKTogViB7XG4gICAgaWYgKCF0aGlzLm1hc2tSZWYpIHJldHVybiAoKHRoaXMuZWxlbWVudCBhcyBhbnkpPy52YWx1ZSB8fCAnJykgYXMgVjtcblxuICAgIGlmICh0aGlzLnVubWFzayA9PT0gJ3R5cGVkJykgcmV0dXJuIHRoaXMubWFza1JlZi50eXBlZFZhbHVlIGFzIFY7XG4gICAgaWYgKHRoaXMudW5tYXNrKSByZXR1cm4gdGhpcy5tYXNrUmVmLnVubWFza2VkVmFsdWUgYXMgVjtcbiAgICByZXR1cm4gdGhpcy5tYXNrUmVmLnZhbHVlIGFzIFY7XG4gIH1cblxuICBzZXQgbWFza1ZhbHVlICh2YWx1ZTogVikge1xuICAgIGlmICh0aGlzLm1hc2tSZWYpIHtcbiAgICAgIGlmICh0aGlzLnVubWFzayA9PT0gJ3R5cGVkJykgdGhpcy5tYXNrUmVmLnR5cGVkVmFsdWUgPSB2YWx1ZTtcbiAgICAgIGVsc2UgaWYgKHRoaXMudW5tYXNrKSB0aGlzLm1hc2tSZWYudW5tYXNrZWRWYWx1ZSA9IHZhbHVlIGFzIHN0cmluZztcbiAgICAgIGVsc2UgdGhpcy5tYXNrUmVmLnZhbHVlID0gdmFsdWUgYXMgc3RyaW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLmVsZW1lbnQsICd2YWx1ZScsIHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgaWYgKHRoaXMuaW1hc2spIHRoaXMuaW5pdE1hc2soKTtcblxuICAgIHRoaXMuX3ZpZXdJbml0aWFsaXplZCA9IHRydWU7XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgaWYgKGNoYW5nZXNbJ2VsZW1lbnRSZWYnXSAmJiAhdGhpcy5pbWFza0VsZW1lbnQpIHRoaXMuaW1hc2tFbGVtZW50ID0gREVGQVVMVF9JTUFTS19FTEVNRU5UO1xuXG4gICAgaWYgKCFjaGFuZ2VzWydpbWFzayddIHx8ICF0aGlzLl92aWV3SW5pdGlhbGl6ZWQpIHJldHVybjtcblxuICAgIGlmICh0aGlzLmltYXNrKSB7XG4gICAgICBpZiAodGhpcy5tYXNrUmVmKSB0aGlzLm1hc2tSZWYudXBkYXRlT3B0aW9ucyh0aGlzLmltYXNrIGFzIFVwZGF0ZU9wdHM8T3B0cz4pO1xuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuaW5pdE1hc2soKTtcbiAgICAgICAgdGhpcy5vbkNoYW5nZSh0aGlzLm1hc2tWYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGVzdHJveU1hc2soKTtcbiAgICB9XG4gIH1cblxuICBkZXN0cm95TWFzayAoKSB7XG4gICAgaWYgKHRoaXMubWFza1JlZikge1xuICAgICAgdGhpcy5tYXNrUmVmLmRlc3Ryb3koKTtcbiAgICAgIGRlbGV0ZSB0aGlzLm1hc2tSZWY7XG4gICAgfVxuICB9XG5cbiAgbmdPbkRlc3Ryb3kgKCkge1xuICAgIHRoaXMuZGVzdHJveU1hc2soKTtcbiAgICB0aGlzLmFjY2VwdC5jb21wbGV0ZSgpO1xuICAgIHRoaXMuY29tcGxldGUuY29tcGxldGUoKTtcbiAgfVxuXG4gIGJlZ2luV3JpdGUgKHZhbHVlOiBWKTogdm9pZCB7XG4gICAgdGhpcy5fd3JpdGluZyA9IHRydWU7XG4gICAgdGhpcy5fd3JpdGluZ1ZhbHVlID0gdmFsdWU7XG4gIH1cblxuICBlbmRXcml0ZSAoKTogViB7XG4gICAgdGhpcy5fd3JpdGluZyA9IGZhbHNlO1xuICAgIHJldHVybiB0aGlzLl93cml0aW5nVmFsdWU7XG4gIH1cblxuICB3cml0ZVZhbHVlKHZhbHVlOiBWKSB7XG4gICAgdmFsdWUgPSAodmFsdWUgPT0gbnVsbCAmJiB0aGlzLnVubWFzayAhPT0gJ3R5cGVkJyA/ICcnIDogdmFsdWUpIGFzIFY7XG5cbiAgICBpZiAodGhpcy5tYXNrUmVmKSB7XG4gICAgICB0aGlzLmJlZ2luV3JpdGUodmFsdWUpO1xuICAgICAgdGhpcy5tYXNrVmFsdWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuZW5kV3JpdGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5lbGVtZW50LCAndmFsdWUnLCB2YWx1ZSk7XG4gICAgICB0aGlzLl9pbml0aWFsVmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICBfb25BY2NlcHQgKCkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5tYXNrVmFsdWU7XG4gICAgLy8gaWYgdmFsdWUgd2FzIG5vdCBjaGFuZ2VkIGR1cmluZyB3cml0aW5nIGRvbid0IGZpcmUgZXZlbnRzXG4gICAgLy8gZm9yIGRldGFpbHMgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91Tm1Bbk5lUi9pbWFza2pzL2lzc3Vlcy8xMzZcbiAgICBpZiAodGhpcy5fd3JpdGluZyAmJiB2YWx1ZSA9PT0gdGhpcy5lbmRXcml0ZSgpKSByZXR1cm47XG4gICAgdGhpcy5vbkNoYW5nZSh2YWx1ZSk7XG4gICAgdGhpcy5hY2NlcHQuZW1pdCh2YWx1ZSk7XG4gIH1cblxuICBfb25Db21wbGV0ZSAoKSB7XG4gICAgdGhpcy5jb21wbGV0ZS5lbWl0KHRoaXMubWFza1ZhbHVlKTtcbiAgfVxuXG4gIHByaXZhdGUgaW5pdE1hc2sgKCkge1xuICAgIHRoaXMubWFza1JlZiA9IHRoaXMuX2ZhY3RvcnkuY3JlYXRlKHRoaXMuZWxlbWVudCwgdGhpcy5pbWFzayBhcyBPcHRzKVxuICAgICAgLm9uKCdhY2NlcHQnLCB0aGlzLl9vbkFjY2VwdC5iaW5kKHRoaXMpKVxuICAgICAgLm9uKCdjb21wbGV0ZScsIHRoaXMuX29uQ29tcGxldGUuYmluZCh0aGlzKSk7XG5cbiAgICBpZiAodGhpcy5faW5pdGlhbFZhbHVlICE9IG51bGwpIHRoaXMud3JpdGVWYWx1ZSh0aGlzLl9pbml0aWFsVmFsdWUpO1xuICAgIGRlbGV0ZSB0aGlzLl9pbml0aWFsVmFsdWU7XG4gIH1cblxuICBzZXREaXNhYmxlZFN0YXRlIChpc0Rpc2FibGVkOiBib29sZWFuKSB7XG4gICAgdGhpcy5fcmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5lbGVtZW50LCAnZGlzYWJsZWQnLCBpc0Rpc2FibGVkKVxuICB9XG5cbiAgcmVnaXN0ZXJPbkNoYW5nZShmbjogKF86IGFueSkgPT4gdm9pZCk6IHZvaWQgeyB0aGlzLm9uQ2hhbmdlID0gZm4gfVxuICByZWdpc3Rlck9uVG91Y2hlZChmbjogKCkgPT4gdm9pZCk6IHZvaWQgeyB0aGlzLm9uVG91Y2hlZCA9IGZuIH1cblxuICBfaGFuZGxlSW5wdXQodmFsdWU6IGFueSk6IHZvaWQge1xuICAgIC8vIGlmIG1hc2sgaXMgYXR0YWNoZWQgYWxsIGlucHV0IGdvZXMgdGhyb3cgbWFza1xuICAgIGlmICh0aGlzLm1hc2tSZWYpIHJldHVybjtcblxuICAgIGlmICghdGhpcy5fY29tcG9zaXRpb25Nb2RlIHx8ICh0aGlzLl9jb21wb3NpdGlvbk1vZGUgJiYgIXRoaXMuX2NvbXBvc2luZykpIHtcbiAgICAgIHRoaXMub25DaGFuZ2UodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIF9jb21wb3NpdGlvblN0YXJ0KCk6IHZvaWQgeyB0aGlzLl9jb21wb3NpbmcgPSB0cnVlOyB9XG5cbiAgX2NvbXBvc2l0aW9uRW5kKHZhbHVlOiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLl9jb21wb3NpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9jb21wb3NpdGlvbk1vZGUgJiYgdGhpcy5faGFuZGxlSW5wdXQodmFsdWUpO1xuICB9XG5cbiAgcHJpdmF0ZSBfaXNBbmRyb2lkKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBpc1BsYXRmb3JtQnJvd3Nlcih0aGlzLl9wbGF0Zm9ybUlkKSAmJiAvYW5kcm9pZCAoXFxkKykvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuIl19